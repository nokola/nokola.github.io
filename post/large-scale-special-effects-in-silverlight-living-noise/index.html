<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>SYSTEM FAILURE  | Special Effects: Living Noise</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.31.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://systemfailure.io/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="Special Effects: Living Noise" />
<meta property="og:description" content="The Living Noise is an animated &ldquo;flow&rdquo; of particles. The particle trajectory is changed by using Perlin Noise (long live Ken Perlin!) I&rsquo;m so excited. Perlin noise is used pretty much in all special effects &ndash; explosions, texture generation, water, clouds, mountains, terrain generation, twinkling stars, halo/weapon effects, etc..
Click below to see the Living Noise sample, which is just one way to use Noise:
Living Noise

Download the source code for Living Noise" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://systemfailure.io/post/large-scale-special-effects-in-silverlight-living-noise/" />



<meta property="article:published_time" content="2009-11-01T21:53:00&#43;00:00"/>

<meta property="article:modified_time" content="2009-11-01T21:53:00&#43;00:00"/>











<meta itemprop="name" content="Special Effects: Living Noise">
<meta itemprop="description" content="The Living Noise is an animated &ldquo;flow&rdquo; of particles. The particle trajectory is changed by using Perlin Noise (long live Ken Perlin!) I&rsquo;m so excited. Perlin noise is used pretty much in all special effects &ndash; explosions, texture generation, water, clouds, mountains, terrain generation, twinkling stars, halo/weapon effects, etc..
Click below to see the Living Noise sample, which is just one way to use Noise:
Living Noise

Download the source code for Living Noise">


<meta itemprop="datePublished" content="2009-11-01T21:53:00&#43;00:00" />
<meta itemprop="dateModified" content="2009-11-01T21:53:00&#43;00:00" />
<meta itemprop="wordCount" content="1706">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Special Effects: Living Noise"/>
<meta name="twitter:description" content="The Living Noise is an animated &ldquo;flow&rdquo; of particles. The particle trajectory is changed by using Perlin Noise (long live Ken Perlin!) I&rsquo;m so excited. Perlin noise is used pretty much in all special effects &ndash; explosions, texture generation, water, clouds, mountains, terrain generation, twinkling stars, halo/weapon effects, etc..
Click below to see the Living Noise sample, which is just one way to use Noise:
Living Noise

Download the source code for Living Noise"/>

  </head>

  <body class="ma0 body-font">
    <style>
      .shadow-bottom {
        -webkit-box-shadow: 0px 0px 15px 0px rgba(175, 175, 175, 1);
        -moz-box-shadow:    0px 0px 15px 0px rgba(175, 175, 175, 1);
        box-shadow:         0px 0px 15px 0px rgba(175, 175, 175, 1);
      }
      .pad-2 {
        padding: 2px 0;
      }
      .sub-space {
        letter-spacing: 0.4px;
      }
      .nested-img img {
        width: initial;
        height: auto;
      }
      a {
        color: #0066ff;
      }
      pre {
        overflow: auto;
        background-color: #e1e1e1;
      }
      a {
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      .word-wrap {
        word-wrap: break-word;
      }
      .lh-copy {
        line-height: 1.42857143;
      }
      .title-font {
        font-weight: 400;
      }
      .body-font {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      .mw6 {
        max-width: 36rem;
      }
      .mt3and5 {
        margin-top: 1.5rem;
      }
      article {
        box-shadow: 0 1px 3px rgba(0,0,0,.1);
        background: white;
      }
      body {
        background: #ecf0f5;
      }
    </style>
    



  
  
    <header class="cover bg-top bg-left shadow-bottom" style="background-image: url('https://systemfailure.io/header/tree1.jpg');">
  
    <div>
      
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l  items-center center">
    <section class="w-100 mw8 center">
      <a href="https://systemfailure.io/" class="f5 fw4 hover-white no-underline white-90 dib">
        SYSTEM FAILURE
        <div class="f7 white-70 pad-2 sub-space">Working with humans. Product care. Coding.</div>
      </a>
      <div class="flex-l items-center">
        
        








      </div>
    </section>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7 ph3 pt2 ph4-ns" role="main">
      
<div class="flex-l mt2 mw8 center"> 
  <div>
      <a href="javascript:history.go(-1)">‚Üê back</a>
      <article class="center cf pa4 mt3 pb1 mw8 word-wrap">
        <time class="f7 pb1 dib mid-gray normal" datetime="2009-11-01T21:53:00Z">
            Nov 1, 2009
        </time>
        <h1 class="f2 mb4 mt1 title-font">
        Special Effects: Living Noise
        </h1>

        
        
      <section class="nested-copy-line-height lh-copy f5 nested-links nested-img dark-gray">
        <p>The Living Noise is an animated &ldquo;flow&rdquo; of particles. The particle trajectory is changed by using <a href="http://www.noisemachine.com/talk1/">Perlin Noise</a> (long live Ken Perlin!) I&rsquo;m so excited. Perlin noise is used pretty much in all special effects &ndash; explosions, texture generation, water, clouds, mountains, terrain generation, twinkling stars, halo/weapon effects, etc..</p>
<p>Click below to see the Living Noise sample, which is just one way to use Noise:</p>
<p><a href="http://nokola.com/livingnoise/">Living Noise</a></p>
<p><a href="http://nokola.com/livingnoise/"><img src="/2009%2f11%2fnoise.jpg" alt="" /></a></p>
<p><a href="http://nokola.com/sources/livingnoise.zip">Download the source code for Living Noise</a></p>
<h2>Basic Explanation of Noise</h2>
<p>If you hear about Perlin Noise for the first time, I bet you have a lot of questions like &ldquo;how does it work?&rdquo; and &ldquo;what is it?&rdquo; and maybe even &ldquo;can my neighbors produce it?&rdquo;</p>
<p>Here is my short explanation. I&rsquo;m not very good at maths, thus will use my own words to describe things. If you&rsquo;re math-savvy, check out Wikipedia or some scientific site out there for the exact description.</p>
<p>Perlin Noise is a &ldquo;continuous noise&rdquo;. What does it mean?</p>
<ul>
<li>It&rsquo;s noise, meaning that it appears to be random in nature. E.g. If you have a function color=Noise(x,y) and plot this on a picture, you&rsquo;ll get random dots (or &ldquo;noise&rdquo;) everywhere!&nbsp;</li>
<li>It&rsquo;s continuous, meaning that it looks &ldquo;smooth&rdquo; when plotted on a surface (no &ldquo;hard edges&rdquo;) </li>
</ul>
<p>The &ldquo;continuous&rdquo; part is very important! As you probably noticed, in nature things doesn&rsquo;t just jump up-and-down, but look smooth and &ldquo;continuous&rdquo;. Take water for example: if you look at ocean waves, they do look kind of random, but at the same time they look smooth as well:</p>
<p>&nbsp;<img src="/2009%2f11%2fwaves.jpg" alt="" /></p>
<p>The Noise() function looks like this:</p>
<p>value = Noise(x, y, z)</p>
<p>Where value would typically be (depends on who implements it) between -1 and 1</p>
<p>The above noise is 3D because its function has 3 parameters: x, y, and z. There are also 1-D noise, 2-D noise, 4-D noise and so on.</p>
<p>For the Living Noise sample, I just need 2D but I implemented the 3D version for fun. It&rsquo;s also slower, so if you&rsquo;re using only 2D, don&rsquo;t run the 3D version &ldquo;just because&rdquo; as I did.</p>
<p>Now is the time to look at how a 3D noise looks like. Take a look at <a href="http://kodierer.blogspot.com/2009/05/oscar-algorithm-silverlight-real-time.html">this external sample</a>, showing a 3d noise on a 2d surface. The Z coordinate means &ldquo;time&rdquo; in that sample, so you&rsquo;ll see nice animated noise that looks like clouds a little bit J If you also read <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">here</a> you&rsquo;ll better understand the meaning of &ldquo;frequency&rdquo;, &ldquo;amplitude&rdquo; and the other parameters as well.</p>
<h2>Using Perlin Noise To Make Living Noise</h2>
<p>By now you should be familiar with Perlin Noise and continuous noise. If you&rsquo;re not please drop me a comment so I can explain it better&nbsp;</p>
<p>Imagine a dot (or &ldquo;particle&rdquo;) on the screen. Let&rsquo;s give our particle has some velocity (vx, vy) measured in [pixels/time], and a location (x,y). If we continuously draw the particle over time, we&rsquo;ll see a straight line, which is boring and dull.</p>
<p>To make the particle more &ldquo;interesting&rdquo; we&rsquo;ll modify its velocity over time as well.</p>
<p>Here are 3 examples of how can we modify the velocity:</p>
<ul>
<li>Completely random: the particle will appear to jump everywhere (mostly around where it started)</li>
<li>Sinusoidal of some sort &ndash; the particle will appear to follow a sine-wave trajectory, better but not perfect&hellip;Anyone could see the motion is predictable.</li>
<li>Using continuous noise: the particle could go anywhere, but smoothly. There will be no jumpiness in behavior like in the first case, or predictable motion as in the second case: Living Noise! The particle travels smoothly, because the noise function is smooth. See Basic Explanation of Noise above and the external links for more info. </li>
</ul>
<p>First, I compute the noise and store it into an image. Storing into an image is not the best way to do it (slower), but it helped me &ldquo;debug&rdquo; the noise visually.</p>
<p>The noise is pre-computed because it doesn&rsquo;t need to change over time.</p>
<p>On every time step (CompositionTarget.Rendering), get the particle&rsquo;s location, and find how its velocity will change based on the noise (see NoiseParticle.cs)</p>
<h3>Adding Lots of Particles</h3>
<p>Since we can do it for one particle, we can as well do it for 3000 to get a nice &ldquo;flow-like&rdquo; image. We&rsquo;ll also add some color to each particle to make everything more interesting.</p>
<h2>Making It Look Good</h2>
<p>Now we have a screenfull of particles, they look pretty impressive, but it&rsquo;s still just a &ldquo;neat effect&rdquo; and I could say not production-ready yet.</p>
<p>Here&rsquo;s why:</p>
<ul>
<li>The particles are just dots &ndash; too small and need to have quite a bit of those to make something useful</li>
<li>The particles doesn&rsquo;t relate to each other, e.g. if two particles are close nearby I&rsquo;d like them to &ldquo;light up&rdquo; or something like that.&nbsp;</li>
<li>Third, I&rsquo;d like all this to be able to look &ldquo;organic&rdquo;, meaning I should be able to compose complex particle interaction and behavior in code-behind (not just modify opacity) </li>
</ul>
<p>The implication from the Third requirement is the most important &ndash; it means I intentionally chose to render the scene on WritableBitmap rather than having 3000&nbsp;&lt;Image /&gt;&nbsp;controls on a Silverlight surface.</p>
<p>It also means that everything will get slower, and we&rsquo;ll have to account for that (see Making It Scale below).</p>
<p>I&rsquo;ll use a quite &ldquo;hacky&rdquo; method to implement the First and Third requirement:</p>
<h3>Modified Blur</h3>
<p>To make a dot appear &ldquo;larger&rdquo; than it is, we just blur it on every frame. That&rsquo;s good but only blur will provide blurry image&hellip;we really need some definition in there as well.</p>
<p>The solution is to blur the &ldquo;screen&rdquo; and overlay with &ldquo;sharp&rdquo; scene on every frame. This means that the longer a pixel stays on screen the blurrier it gets (you can think about the dots &ldquo;dissolving&rdquo; into thin air), and also definition and sharpness of newly created dots is preserved.</p>
<p>Interestingly enough, dots that are close to each other will provide a bigger &ldquo;blur cloud&rdquo; which makes for some non-trivial effect of multiple dots gathering at the same place (Second requirement)</p>
<p>We also need to fade the screen just a bit on every frame otherwise we&rsquo;ll end up with some huge color field (which might be good for another demo).</p>
<h2>Making It Scale</h2>
<p>If you follow everything so far, and used the classic algorithm for Blur, you&rsquo;ll end up with the Living Noise. At this point, it might be too slow. We want to make it full screen, and also have it use not-too-much CPU, so that whatever we&rsquo;re doing can have extra cycles for something else (e.g. in-game AI or other effects).</p>
<h3>Optimized Blur</h3>
<p>The default Gaussian blur is quite slow. The hack I&rsquo;m using averages the 2 horizontal neighboring pixels for each pixel on screen, to achieve horizontal blur. Then do the same vertically, to get vertical blur. The 2 combined give us the so-called &ldquo;box blur&rdquo;, which is much faster than Gaussian blur without any noticeable fidelity decrease for the Living noise (if you don&rsquo;t believe it, try both and see for yourself).</p>
<h3>Multithreading</h3>
<p>The nice thing about our optimized blur is that it can easily be multi-threaded. Since many people now have at least a dual-core system, having 2 threads to compute the blur really allows us to take it full screen!</p>
<p>As a further optimization, you can apply the blur every second, third, or fourth frame without having the quality degrade too bad &ndash; good if your game, or whatever you&rsquo;re doing doesn&rsquo;t have &ldquo;make Living Noise&rdquo; as the primary goal.</p>
<h2>Making It Stick To Objects</h2>
<p>Here you&rsquo;ll see how the Third requirement in &ldquo;Making It Look Good&rdquo; pays off.</p>
<p>Adding &ldquo;sticky&rdquo; is easy:&nbsp;</p>
<ol>
<li>Create a new WritableBitmap hitTestSurface </li>
<li>Draw TextBlock or whatever you&rsquo;d like the noise to &ldquo;stick&rdquo; to there&nbsp;</li>
<li>When calculating the velocity over time for the particles on every frame, revert the time for particles that hit a non-zero pixel on hitTestSurface</li>
</ol>
<p>You&rsquo;re Done!</p>
<h2>Usages Of Living Noise</h2>
<p>These come up from the top of my head:&nbsp;</p>
<ul>
<li>Just show it on the main menu like a cool tweak&nbsp;</li>
<li>Use it as &ldquo;living ornaments&rdquo; to stuff (menus again)&nbsp;</li>
<li>Explosions&nbsp;</li>
<li>Weird space effect&nbsp;</li>
<li>Engine exhaust. Should be fairly easy once and you can pick your &ldquo;exhaust of choice&rdquo; by changing the x or y value of the start location of the exhaust)&nbsp;</li>
<li>Holes in the fabric of space &ndash; if you create particles from a circular shape, it can look like someone tore the space time continuum&nbsp;&nbsp;</li>
</ul>
<h2>Further Noise Usage</h2>
<p>I have not experimented a lot with these yet, but here are some ideas of what you could do with Noise in general:&nbsp;</p>
<ul>
<li>Clouds, in particular if you play with the octaves/sliding you can make clouds that appear moving towards or against you.&nbsp;</li>
<li>If you draw a line dot by dot and modify every dot&rsquo;s location based on noise you&rsquo;ll likely get lightning effect&nbsp;</li>
<li>Draw mountains by hand then modify the image with noise to add terrain artifacts. Note: there are many &ldquo;noise generated terrains&rdquo; out there. I&rsquo;m proposing a manual + automated method to achieve best results and allow more tweaking&nbsp;</li>
<li>Have some sin/cos movements (e.g. enemy battle ships), but modify the location of the ship using perlin noise. The ship will still move according to predictable trajectory, but it will look more interesting </li>
<li>Explosions (take the Living noise example and make the particles &ldquo;die&rdquo; fast). Also, it would be nice to make the particles fade more the further they are from the explosion for 2 reasons: o Looks more life-like o You can ensure that the explosion stays within a certain rage (e.g. 64x64 pixels) &ndash; this allows you to render an explosion fast, without the need to go fullscreen. You can have lots of explosions that way, and maybe one big &ldquo;boss&rdquo; explosion&nbsp;</li>
<li>Lava flowing down a mountain (I have yet to see this): add gravity to the Living Noise, and instead of velocity modify the particle positions. You can use the &ldquo;sticky&rdquo; properly of the Living Noise to have it burn around rocks and/or other objects&nbsp;</li>
<li>Other stuff&nbsp;&nbsp;</li>
</ul>
<h2>References/Very Cool Stuff Links</h2>
<p>Fast Blur: <a href="http://www.gamasutra.com/view/feature/3102/four_tricks_for_fast_blurring_in_.php">http://www.gamasutra.com/view/feature/3102/four_tricks_for_fast_blurring_in_.php</a></p>
<p>Rene's blog (this demo was inspired by his realtime noise, although I used another slower algorithm): <a href="http://kodierer.blogspot.com/">http://kodierer.blogspot.com/</a></p>
<p>Rick Barazza's cool samples: <a href="http://www.cynergysystems.com/blogs/page/rickbarraza">http://www.cynergysystems.com/blogs/page/rickbarraza</a>&nbsp;(found this from a colleague after he saw my demo)</p>
<p>Hope you liked this post! Please comment!</p>
<p>&nbsp;</p>

      </section>
      


      <div class="mt5"></div>
      
<div id="graphcomment"></div>
<script type="text/javascript">
  window.graphcomment_id = 'nokola-blog';
  (function() {
    var gc = document.createElement('script'); gc.type = 'text/javascript'; gc.async = true;
    gc.src = 'https://graphcomment.com/js/integration.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(gc);
  })();
</script>

      </article>
  </div>
</div>

    </main>
    <footer class="bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f7 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://systemfailure.io/" >
    &copy; 2018 SYSTEM FAILURE
  </a>
  








  </div>
</footer>

    <script src="https://systemfailure.io/dist/app.bundle.js" async></script>

  </body>
</html>
