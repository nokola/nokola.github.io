<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>System Failure | Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)</title><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.59.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link href=https://systemfailure.io/dist/main.css rel=stylesheet type=text/css><meta property="og:title" content="Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)"><meta property="og:description" content="I read somewhere online that Hue changes can't be done in pixel shader 2.0, due to limitation of 64 instructions per slot.
Here's the sample that proves otherwise:
Download source code
 Indeed the RGB-to-HSL-to-RGB conversion takes about 100 instructions in its typical implementation. PS 2.0 which is the shader model supported by Silverlight 3 only allows for 64 arithmetic instructions, as outlined in this comparison between pixel shaders on Wikipedia"><meta property="og:type" content="article"><meta property="og:url" content="https://systemfailure.io/post/someone-said-it-was-impossible-hue-shift-in-pixel-shader-20-silverlight/"><meta property="article:published_time" content="2010-02-09T20:30:00+00:00"><meta property="article:modified_time" content="2010-02-09T20:30:00+00:00"><meta itemprop=name content="Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)"><meta itemprop=description content="I read somewhere online that Hue changes can't be done in pixel shader 2.0, due to limitation of 64 instructions per slot.
Here's the sample that proves otherwise:
Download source code
 Indeed the RGB-to-HSL-to-RGB conversion takes about 100 instructions in its typical implementation. PS 2.0 which is the shader model supported by Silverlight 3 only allows for 64 arithmetic instructions, as outlined in this comparison between pixel shaders on Wikipedia"><meta itemprop=datePublished content="2010-02-09T20:30:00&#43;00:00"><meta itemprop=dateModified content="2010-02-09T20:30:00&#43;00:00"><meta itemprop=wordCount content="850"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)"><meta name=twitter:description content="I read somewhere online that Hue changes can't be done in pixel shader 2.0, due to limitation of 64 instructions per slot.
Here's the sample that proves otherwise:
Download source code
 Indeed the RGB-to-HSL-to-RGB conversion takes about 100 instructions in its typical implementation. PS 2.0 which is the shader model supported by Silverlight 3 only allows for 64 arithmetic instructions, as outlined in this comparison between pixel shaders on Wikipedia"></head><body class="ma0 body-font"><style>.shadow-bottom{-webkit-box-shadow:0 0 15px 0 #afafaf;-moz-box-shadow:0 0 15px 0 #afafaf;box-shadow:0 0 15px 0 #afafaf}.pad-2{padding:2px 0}.sub-space{display:block;font-size:20px;font-weight:400;padding-top:10px}.nested-img img{width:initial;height:auto}a{color:#06f}pre{overflow:auto;color:#ddd;white-space:pre;border:1px solid #41a85f;border-left:none;border-right:none;hyphens:none;position:relative;border-radius:2px;margin-left:-32px;margin-right:-32px;padding:0 16px;box-shadow:0 2px 14px 0 #0b0107}a{text-decoration:none}a:hover{text-decoration:underline}.word-wrap{word-wrap:break-word}.lh-copy{line-height:1.42857143}.title-font{font-weight:700;color:#cecece}.body-font{font-family:Georgia,times new roman,Times,serif}.mw6{max-width:36rem}.mt3and5{margin-top:1.5rem}article{border-radius:4px 4px}body{background:#2f3031;color:#eee}.main-link{display:block;color:inherit}.main-link:hover{text-decoration:none}.summary-article:hover{box-shadow:0 0 12px 7px rgba(0,0,0,.12)}article img{display:block}.nested-links a{color:#54acd2;font-variant:small-caps;letter-spacing:.8px}.top-link:hover{background:#464646;border-radius:4px;text-decoration:none}.gradient-top{background:#020024;background:linear-gradient(90deg,rgb(121,66,0) 0%,rgb(107,74,0) 35%,rgb(57,42,0) 100%);height:4px;border-radius:4px 4px 0 0}.gradient-top.single,.summary-article:hover .gradient-top{background:linear-gradient(90deg,rgb(19,99,3) 0%,rgb(16,68,52) 35%,rgb(32,45,31) 100%)}.utterances{margin-left:0}.f5{font-size:18px}</style><header class="mb5 cover bg-top bg-left shadow-bottom" style=background-image:url(https://systemfailure.io/header/tree1.jpg)><div><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l items-center center"><section class="w-100 mw8 center"><a href=https://systemfailure.io/ class="top-link pa3 f5 fw4 hover-white no-underline white-90 dib">System Failure<div class="f7 white-70 pad-2 sub-space">Nokola&#39;s handwritten blog on software and humans.</div></a><div class="flex-l items-center"></div></section></div></nav></div></header><main class="pb7 ph0 ph4-ns ph0-m" role=main><div class="flex-l mt2 mw8 center"><div><article class="center cf word-wrap"><div class="gradient-top single"></div><h1 class="f3 title-font ph4-ns ph3 pt3 mt3">Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)</h1><div class="ph4-ns mw8 ph3 pb2"><p class="f7 pt1 pb3 silver"><span>Feb 9, 2010</span></p><section class="nested-copy-line-height lh-copy f5 nested-links nested-img light-gray"><p>I read somewhere online that Hue changes can't be done in pixel shader 2.0, due to limitation of 64 instructions per slot.</p><p>Here's the sample that proves otherwise:</p><p><a href=http://nokola.com/sources/HueShift.zip>Download source code</a></p><iframe src="/sample.aspx?xap=HueShift" width=640px height=400px style="border:0 solid" frameborder=0></iframe><p>Indeed the RGB-to-HSL-to-RGB conversion takes about 100 instructions in its typical implementation. PS 2.0 which is the shader model supported by Silverlight 3 only allows for 64 arithmetic instructions, as outlined in this <a title="Comparison Between Pixel Shaders on Wikipedia" href=http://en.wikipedia.org/wiki/Hlsl>comparison between pixel shaders on Wikipedia</a></p><p>How can we optimize it?</p><p>Optimizing pixel shader instruction slots is nice - in a typical C# world, you'd be adding if() statements to make your code run faster like this:</p><pre><strong>&nbsp;&nbsp;&nbsp; if ( HSV.y != 0 )</strong> {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_h = HSV.x * 6;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_i = floor(var_h);&nbsp;&nbsp; // Or ... var_i = floor( var_h )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_1 = HSV.z * (1.0 - HSV.y);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_3 = HSV.z * (1.0 - HSV.y * (1-(var_h-var_i)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (var_i == 0) { RGB = QUAD_REAL3(HSV.z, var_3, var_1); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 1) { RGB = QUAD_REAL3(var_2, HSV.z, var_1); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 2) { RGB = QUAD_REAL3(var_1, HSV.z, var_3); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 3) { RGB = QUAD_REAL3(var_1, var_2, HSV.z); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 4) { RGB = QUAD_REAL3(var_3, var_1, HSV.z); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { RGB = QUAD_REAL3(HSV.z, var_1, var_2); }<br>&nbsp;&nbsp; }</pre><p>Not with pixel shaders. If you look carefully at the bold if statement, removing it does not change the program logic. It just takes an extra instruction slot. In reality, I think the pixel shader code will run with the same speed with or without the if() (not 100% sure so correct me if needed).</p><p>With this knowledge, I decided to do these optimizations:</p><p>1. Instead of HSL-to-RGB, use HSV-to-RGB. The reference <a href=http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html>NVidia Shader Library</a> implementation (source code <a href=http://developer.download.nvidia.com/shaderlibrary/packages/post_RGB_from_HSV.fx.zip>here</a>)&nbsp;of HSV-RGB-HSV takes ~70 or so&nbsp;slots.</p><p>2. Combine the min_channel() and max_channel() functions into 1&nbsp;- saves a couple if() statements</p><p>3. Take out the if (x &lt; 0) (x += 1) checks in the RGB-HSV function, and execute them once instead of twice, after the hue is modified.</p><p>4. Remove the "obsolete" if()-s like the one above</p><p>I was very happy to see that it just fit in the 64-instruction slot of PS 2.0! Note that it hits the limit and more complex Hue stuff may need further optimizations! :) If you do so, please let me know! Anyway hue tricks that don't use more slots are OK.</p><p>Here's the complete Shazzam-friendly source of the .fx file (also included in the sample project source above).</p><pre>/// &lt;summary&gt;Hue shift&lt;/summary&gt;<br>/// &lt;minValue&gt;0&lt;/minValue&gt;<br>/// &lt;maxValue&gt;1&lt;/maxValue&gt;<br>/// &lt;defaultValue&gt;0&lt;/defaultValue&gt;<br>float HueShift : register(c0);</pre><pre>sampler2D Samp : register(S0);<br>#define QUAD_REAL float<br>#define QUAD_REAL3 float3</pre><pre>QUAD_REAL3 rgb_to_hsv_no_clip(QUAD_REAL3 RGB)<br>{<br>&nbsp;&nbsp;&nbsp; QUAD_REAL3 HSV;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;float minChannel, maxChannel;<br>&nbsp;if (RGB.x &gt; RGB.y) {<br>&nbsp;&nbsp;maxChannel = RGB.x;<br>&nbsp;&nbsp;minChannel = RGB.y;<br>&nbsp;}<br>&nbsp;else {<br>&nbsp;&nbsp;maxChannel = RGB.y;<br>&nbsp;&nbsp;minChannel = RGB.x;<br>&nbsp;}<br>&nbsp;<br>&nbsp;if (RGB.z &gt; maxChannel) maxChannel = RGB.z;<br>&nbsp;if (RGB.z &lt; minChannel) minChannel = RGB.z;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; HSV.xy = 0;<br>&nbsp;&nbsp;&nbsp; HSV.z = maxChannel;<br>&nbsp;&nbsp;&nbsp; QUAD_REAL delta = maxChannel - minChannel;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Delta RGB value <br>&nbsp;&nbsp;&nbsp; if (delta != 0) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If gray, leave H &amp; S at zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSV.y = delta / HSV.z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL3 delRGB;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delRGB = (HSV.zzz - RGB + 3*delta) / (6.0*delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( RGB.x == HSV.z ) HSV.x = delRGB.z - delRGB.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( RGB.y == HSV.z ) HSV.x = ( 1.0/3.0) + delRGB.x - delRGB.z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( RGB.z == HSV.z ) HSV.x = ( 2.0/3.0) + delRGB.y - delRGB.x;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return (HSV);<br>}</pre><pre>QUAD_REAL3 hsv_to_rgb(QUAD_REAL3 HSV)<br>{<br>&nbsp;&nbsp;&nbsp; QUAD_REAL3 RGB = HSV.z;<br>&nbsp;&nbsp;&nbsp; //if ( HSV.y != 0 ) { // we don't really need this since it just adds an obsolete instruction slot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_h = HSV.x * 6;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_i = floor(var_h);&nbsp;&nbsp; // Or ... var_i = floor( var_h )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_1 = HSV.z * (1.0 - HSV.y);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_3 = HSV.z * (1.0 - HSV.y * (1-(var_h-var_i)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (var_i == 0) { RGB = QUAD_REAL3(HSV.z, var_3, var_1); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 1) { RGB = QUAD_REAL3(var_2, HSV.z, var_1); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 2) { RGB = QUAD_REAL3(var_1, HSV.z, var_3); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 3) { RGB = QUAD_REAL3(var_1, var_2, HSV.z); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 4) { RGB = QUAD_REAL3(var_3, var_1, HSV.z); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { RGB = QUAD_REAL3(HSV.z, var_1, var_2); }<br>&nbsp;&nbsp; //}<br>&nbsp;&nbsp; return (RGB);<br>}</pre><pre>float4 main(float2 uv : TEXCOORD) : COLOR<br>{<br>&nbsp;float4 col = tex2D(Samp, uv);<br>&nbsp;float3 hsv = rgb_to_hsv_no_clip(col.xyz);<br>&nbsp;&nbsp;&nbsp; hsv.x+=HueShift;<br>&nbsp;&nbsp;&nbsp; //if ( hsv.x &lt; 0.0 ) { hsv.x += 1.0; }<br>&nbsp;&nbsp;&nbsp; if ( hsv.x &gt; 1.0 ) { hsv.x -= 1.0; }<br>&nbsp;&nbsp;&nbsp; return float4(hsv_to_rgb(hsv),col.w);<br>}</pre><pre>&nbsp;</pre><pre>btw, <a href=http://weblogs.asp.net/scottgu/archive/2010/02/08/vs-2010-net-4-release-candidate.aspx>Visual Studio 2010 RC</a> is out for MSDN subsribers (public tomorrow) and I'm going to publish all samples in VS 2010 from now on :)</pre><p>Hope you like it!</p></section><div class=mt5></div><script src=https://utteranc.es/client.js repo=nokola/blog issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></div></article></div></div></main><footer class="bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f7 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://systemfailure.io/>&copy; 2020 System Failure</a></div></footer><script src=https://systemfailure.io/dist/app.bundle.js async></script></body></html>