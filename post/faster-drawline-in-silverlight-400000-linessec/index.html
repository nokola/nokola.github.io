<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>System Failure | Fast DrawLine() in Silverlight</title><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.59.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link href=https://systemfailure.io/dist/main.css rel=stylesheet type=text/css><meta property="og:title" content="Fast DrawLine() in Silverlight"><meta property="og:description" content="How fast can you make it go?
How about this loop that draws the line:[code:c#]
int inc = incy1 * w &#43; incx;
for (int i = 0; i &lt; lenY; i&#43;&#43;) {
&nbsp;&nbsp;&nbsp; pixels[index &gt;&gt; PRECISION_SHIFT] = color;
&nbsp;&nbsp;&nbsp;&nbsp;index &#43;= inc;
}[/code]
40FPS * 10000 lines = 400,000 lines/sec
Note: in my perf tests I did a single-threaded version, so if you have multiple cores (2-4), you might be able to get to more than 0."><meta property="og:type" content="article"><meta property="og:url" content="https://systemfailure.io/post/faster-drawline-in-silverlight-400000-linessec/"><meta property="article:published_time" content="2009-11-06T22:39:00+00:00"><meta property="article:modified_time" content="2009-11-06T22:39:00+00:00"><meta itemprop=name content="Fast DrawLine() in Silverlight"><meta itemprop=description content="How fast can you make it go?
How about this loop that draws the line:[code:c#]
int inc = incy1 * w &#43; incx;
for (int i = 0; i &lt; lenY; i&#43;&#43;) {
&nbsp;&nbsp;&nbsp; pixels[index &gt;&gt; PRECISION_SHIFT] = color;
&nbsp;&nbsp;&nbsp;&nbsp;index &#43;= inc;
}[/code]
40FPS * 10000 lines = 400,000 lines/sec
Note: in my perf tests I did a single-threaded version, so if you have multiple cores (2-4), you might be able to get to more than 0."><meta itemprop=datePublished content="2009-11-06T22:39:00&#43;00:00"><meta itemprop=dateModified content="2009-11-06T22:39:00&#43;00:00"><meta itemprop=wordCount content="587"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Fast DrawLine() in Silverlight"><meta name=twitter:description content="How fast can you make it go?
How about this loop that draws the line:[code:c#]
int inc = incy1 * w &#43; incx;
for (int i = 0; i &lt; lenY; i&#43;&#43;) {
&nbsp;&nbsp;&nbsp; pixels[index &gt;&gt; PRECISION_SHIFT] = color;
&nbsp;&nbsp;&nbsp;&nbsp;index &#43;= inc;
}[/code]
40FPS * 10000 lines = 400,000 lines/sec
Note: in my perf tests I did a single-threaded version, so if you have multiple cores (2-4), you might be able to get to more than 0."></head><body class="ma0 body-font"><style>.shadow-bottom{-webkit-box-shadow:0 0 15px 0 #afafaf;-moz-box-shadow:0 0 15px 0 #afafaf;box-shadow:0 0 15px 0 #afafaf}.pad-2{padding:2px 0}.sub-space{display:block;font-size:20px;font-weight:400;padding-top:10px}.nested-img img{width:initial;height:auto}a{color:#06f}pre{overflow:auto;color:#ddd;white-space:pre;border:1px solid #41a85f;border-left:none;border-right:none;hyphens:none;position:relative;border-radius:2px;margin-left:-32px;margin-right:-32px;padding:0 16px;box-shadow:0 2px 14px 0 #0b0107}a{text-decoration:none}a:hover{text-decoration:underline}.word-wrap{word-wrap:break-word}.lh-copy{line-height:1.42857143}.title-font{font-weight:700;color:#cecece}.body-font{font-family:Georgia,times new roman,Times,serif}.mw6{max-width:36rem}.mt3and5{margin-top:1.5rem}article{border-radius:4px 4px}body{background:#2f3031;color:#eee}.main-link{display:block;color:inherit}.main-link:hover{text-decoration:none}.summary-article:hover{box-shadow:0 0 12px 7px rgba(0,0,0,.12)}article img{display:block}.nested-links a{color:#54acd2;font-variant:small-caps;letter-spacing:.8px}.top-link:hover{background:#464646;border-radius:4px;text-decoration:none}.gradient-top{background:#020024;background:linear-gradient(90deg,rgb(121,66,0) 0%,rgb(107,74,0) 35%,rgb(57,42,0) 100%);height:4px;border-radius:4px 4px 0 0}.gradient-top.single,.summary-article:hover .gradient-top{background:linear-gradient(90deg,rgb(19,99,3) 0%,rgb(16,68,52) 35%,rgb(32,45,31) 100%)}.utterances{margin-left:0}.f5{font-size:18px}</style><header class="mb5 cover bg-top bg-left shadow-bottom" style=background-image:url(https://systemfailure.io/header/tree1.jpg)><div><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l items-center center"><section class="w-100 mw8 center"><a href=https://systemfailure.io/ class="top-link pa3 f5 fw4 hover-white no-underline white-90 dib">System Failure<div class="f7 white-70 pad-2 sub-space">Nokola&#39;s handwritten blog on software and humans.</div></a><div class="flex-l items-center"></div></section></div></nav></div></header><main class="pb7 ph0 ph4-ns ph0-m" role=main><div class="flex-l mt2 mw8 center"><div><article class="center cf word-wrap"><div class="gradient-top single"></div><h1 class="f3 title-font ph4-ns ph3 pt3 mt3">Fast DrawLine() in Silverlight</h1><div class="ph4-ns mw8 ph3 pb2"><p class="f7 pt1 pb3 silver"><span>Nov 6, 2009</span></p><section class="nested-copy-line-height lh-copy f5 nested-links nested-img light-gray"><p>How fast can you make it go?</p><p>How about this loop that draws the line:[code:c#]<br>int inc = incy1 * w + incx;<br>for (int i = 0; i &lt; lenY; i++) {<br>&nbsp;&nbsp;&nbsp; pixels[index &gt;&gt; PRECISION_SHIFT] = color;<br>&nbsp;&nbsp;&nbsp;&nbsp;index += inc;<br>}[/code]</p><p>40FPS * 10000 lines = 400,000 lines/sec</p><p>Note: in my perf tests I did a single-threaded version, so if you have multiple cores (2-4), you might be able to get to more than 0.4mln lines/sec :)</p><p>I looked at the excellent posts from Rene about <a href=http://kodierer.blogspot.com/2009/11/drawing-shapes-silverlight.html>Drawing Shapes in Silverlight</a>, and decided to give the DrawLine() code a whirl :) After trying to optimize it for some time, I ended up with code that runs twice as fast!</p><p>There is no sample here, because I expect that Rene will integrate it/try it out in his library (that&rsquo;s really the best place for the code now to avoid multiple sample DLLs)</p><p>Here is the complete DrawLine() with my optimizations:[code:c#]</p><p>public static void DrawLineFast(this WriteableBitmap bmp, int x1, int y1, int x2, int y2, int color)<br>{<br>&nbsp;&nbsp;&nbsp; // Use refs for faster access (really important!) speeds up a lot!&nbsp;</p><p>&nbsp;&nbsp;&nbsp; int w = bmp.PixelWidth;<br>&nbsp;&nbsp;&nbsp; int[] pixels = bmp.Pixels;</p><p>&nbsp;&nbsp;&nbsp; // Distance start and end point</p><p>&nbsp;&nbsp;&nbsp; int dx = x2 - x1;<br>&nbsp;&nbsp;&nbsp; int dy = y2 - y1;</p><p>&nbsp;&nbsp;&nbsp; const int PRECISION_SHIFT = 8;<br>&nbsp;&nbsp;&nbsp; const int PRECISION_VALUE = 1 &lt;&lt; PRECISION_SHIFT;</p><p>&nbsp;&nbsp;&nbsp; // Determine slope (absoulte value)</p><p>&nbsp;&nbsp;&nbsp; int lenX, lenY;<br>&nbsp;&nbsp;&nbsp; int incy1;<br>&nbsp;&nbsp;&nbsp; if (dy &gt;= 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incy1 = PRECISION_VALUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lenY = dy;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incy1 = -PRECISION_VALUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lenY = -dy;<br>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; int incx1;<br>&nbsp;&nbsp;&nbsp; if (dx &gt;= 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incx1 = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lenX = dx;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incx1 = -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lenX = -dx;<br>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; if (lenX &gt; lenY)<br>&nbsp;&nbsp;&nbsp; { // x increases by +/- 1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Init steps and start</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int incy = (dy &lt;&lt; PRECISION_SHIFT) / lenX;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y = y1 &lt;&lt; PRECISION_SHIFT;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Walk the line!</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; lenX; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pixels[(y &gt;&gt; PRECISION_SHIFT) * w + x1] = color;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x1 += incx1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += incy;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; { // since y increases by +/-1, we can safely add (*h) before the for() loop, since there is no fractional value for y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Prevent divison by zero</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lenY == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Init steps and start</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int incx = (dx &lt;&lt; PRECISION_SHIFT) / lenY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = (x1 + y1 * w) &lt;&lt; PRECISION_SHIFT;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Walk the line!</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inc = incy1 * w + incx;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; lenY; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pixels[index &gt;&gt; PRECISION_SHIFT] = color;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index += inc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><p>[/code]</p><h2>Summary of Optimizations Done</h2><ul><li>Moved from using float to using fixed point</li><li>Took advantage of the fact that if the line is longer in the y direction, vs the x direction (vertically-looking line), y will change by 1 on each iteration. This allows me to remove the multiplication in the innermost line drawing loop</li><li>Removed extra variables, so that remaining variables can be optimized by the JIT compiler, hopefully in CPU registers</li></ul><p>Hope you like it! Please comment! Also, if you can make it faster, please do!</p><p>&nbsp;</p></section><div class=mt5></div><script src=https://utteranc.es/client.js repo=nokola/blog issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></div></article></div></div></main><footer class="bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f7 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://systemfailure.io/>&copy; 2020 System Failure</a></div></footer><script src=https://systemfailure.io/dist/app.bundle.js async></script></body></html>